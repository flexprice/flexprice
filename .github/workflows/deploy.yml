name: Build, Push & Deploy to AWS ECS

on:
  push:
    branches: [develop, main]

permissions:
  id-token: write
  contents: read

env:
  ECR_REGISTRY: ${{ vars.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}

jobs:
  # ──────────────────────────────────────────────────────────────────────────
  # Job 1: Build the Docker image and push it to ECR
  # ──────────────────────────────────────────────────────────────────────────
  build:
    name: Build & Push Docker Image
    runs-on: self-hosted
    outputs:
      image: ${{ steps.set-image.outputs.image }}

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-cicd
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Dockerfile.ecs
          platforms: linux/arm64
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}

      - name: Set image output
        id: set-image
        run: echo "image=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}" >> $GITHUB_OUTPUT

  # ──────────────────────────────────────────────────────────────────────────
  # Job 2: Resolve deployment config based on branch
  #
  #   develop → staging environment
  #   main    → production environment
  #
  # GitHub Actions variables required:
  #
  #   Production  (main branch):
  #     PROD_ECS_CLUSTER           - ECS cluster name  (default: prod-cluster-v1)
  #     PROD_API_SERVICE_NAME      - ECS service name for API
  #     PROD_CONSUMER_SERVICE_NAME - ECS service name for Consumer
  #     PROD_WORKER_SERVICE_NAME   - ECS service name for Temporal Worker
  #     PROD_DEPLOY_REGIONS        - JSON array, e.g. ["ap-south-1","us-east-1"]
  #                                  (default: ["ap-south-1"])
  #
  #   Staging  (develop branch):
  #     STAGING_ECS_CLUSTER           - ECS cluster name
  #     STAGING_API_SERVICE_NAME      - ECS service name for API
  #     STAGING_CONSUMER_SERVICE_NAME - ECS service name for Consumer
  #     STAGING_WORKER_SERVICE_NAME   - ECS service name for Temporal Worker
  #     STAGING_DEPLOY_REGIONS        - JSON array  (default: ["ap-south-1"])
  #
  # Task definition families are always resolved from the ECS service —
  # no separate variable is needed.
  # ──────────────────────────────────────────────────────────────────────────
  resolve-config:
    name: Resolve deployment config
    runs-on: self-hosted
    outputs:
      cluster:          ${{ steps.config.outputs.cluster }}
      api_service:      ${{ steps.config.outputs.api_service }}
      consumer_service: ${{ steps.config.outputs.consumer_service }}
      worker_service:   ${{ steps.config.outputs.worker_service }}
      regions:          ${{ steps.config.outputs.regions }}

    steps:
      - name: Set config based on branch
        id: config
        env:
          # Production variables
          PROD_CLUSTER:   ${{ vars.PROD_ECS_CLUSTER }}
          PROD_API:       ${{ vars.PROD_API_SERVICE_NAME }}
          PROD_CONSUMER:  ${{ vars.PROD_CONSUMER_SERVICE_NAME }}
          PROD_WORKER:    ${{ vars.PROD_WORKER_SERVICE_NAME }}
          PROD_REGIONS:   ${{ vars.PROD_DEPLOY_REGIONS }}
          # Staging variables
          STAGING_CLUSTER:  ${{ vars.STAGING_ECS_CLUSTER }}
          STAGING_API:      ${{ vars.STAGING_API_SERVICE_NAME }}
          STAGING_CONSUMER: ${{ vars.STAGING_CONSUMER_SERVICE_NAME }}
          STAGING_WORKER:   ${{ vars.STAGING_WORKER_SERVICE_NAME }}
          STAGING_REGIONS:  ${{ vars.STAGING_DEPLOY_REGIONS }}
        run: |
          if [ "${{ github.ref_name }}" = "main" ]; then
            echo "cluster=${PROD_CLUSTER:-prod-cluster-v1}"       >> $GITHUB_OUTPUT
            echo "api_service=$PROD_API"                          >> $GITHUB_OUTPUT
            echo "consumer_service=$PROD_CONSUMER"                >> $GITHUB_OUTPUT
            echo "worker_service=$PROD_WORKER"                    >> $GITHUB_OUTPUT
            echo "regions=${PROD_REGIONS:-[\"ap-south-1\"]}"     >> $GITHUB_OUTPUT
          else
            echo "cluster=${STAGING_CLUSTER}"                     >> $GITHUB_OUTPUT
            echo "api_service=$STAGING_API"                       >> $GITHUB_OUTPUT
            echo "consumer_service=$STAGING_CONSUMER"             >> $GITHUB_OUTPUT
            echo "worker_service=$STAGING_WORKER"                 >> $GITHUB_OUTPUT
            echo "regions=${STAGING_REGIONS:-[\"ap-south-1\"]}"  >> $GITHUB_OUTPUT
          fi

  # ──────────────────────────────────────────────────────────────────────────
  # Job 3: Deploy — one run per region (matrix), after build + config resolve
  #
  # For each service the task definition family is always derived from the
  # running ECS service (describe-services → taskDefinition ARN → family name).
  # ──────────────────────────────────────────────────────────────────────────
  deploy:
    name: Deploy to ECS (${{ matrix.region }})
    needs: [build, resolve-config]
    runs-on: self-hosted
    strategy:
      matrix:
        region: ${{ fromJson(needs.resolve-config.outputs.regions) }}
      fail-fast: false

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-cicd
          aws-region: ${{ matrix.region }}

      - name: Deploy all ECS services
        env:
          IMAGE:            ${{ needs.build.outputs.image }}
          CLUSTER:          ${{ needs.resolve-config.outputs.cluster }}
          REGION:           ${{ matrix.region }}
          ECR_REPO_PREFIX:  ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}
          API_SERVICE:      ${{ needs.resolve-config.outputs.api_service }}
          CONSUMER_SERVICE: ${{ needs.resolve-config.outputs.consumer_service }}
          WORKER_SERVICE:   ${{ needs.resolve-config.outputs.worker_service }}
        run: |
          set -euo pipefail

          # ---------------------------------------------------------------
          # deploy_service <service-name>
          #
          # 1. Derives task definition family from the running ECS service
          # 2. Fetches current task definition
          # 3. Replaces the image for any container whose current image
          #    starts with the ECR repo prefix
          # 4. Registers the new revision
          # 5. Forces a new deployment on the service
          # ---------------------------------------------------------------
          deploy_service() {
            local SERVICE="$1"

            echo ""
            echo "==> Deploying: $SERVICE  |  region: $REGION  |  cluster: $CLUSTER"

            # Derive task definition family from the service
            TASK_ARN=$(aws ecs describe-services \
              --cluster "$CLUSTER" \
              --services "$SERVICE" \
              --region "$REGION" \
              --query 'services[0].taskDefinition' \
              --output text)
            # Strip ARN prefix and revision suffix  e.g. arn:.../family:42 → family
            TASK_FAMILY=$(echo "$TASK_ARN" | sed 's|.*/||' | sed 's|:[0-9]*$||')
            echo "  Task family: $TASK_FAMILY"

            # Fetch the latest task definition JSON
            TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition "$TASK_FAMILY" \
              --region "$REGION" \
              --query 'taskDefinition')

            # Update image for containers that use this ECR repository,
            # and strip read-only fields not accepted by register-task-definition
            NEW_TASK_DEF=$(echo "$TASK_DEF" | python3 -c "
import json, sys

td = json.load(sys.stdin)
ecr_prefix = '$ECR_REPO_PREFIX'
new_image   = '$IMAGE'

for c in td.get('containerDefinitions', []):
    if c.get('image', '').startswith(ecr_prefix):
        c['image'] = new_image

for f in [
    'taskDefinitionArn', 'revision', 'status',
    'requiresAttributes', 'compatibilities',
    'registeredAt', 'registeredBy',
]:
    td.pop(f, None)

print(json.dumps(td))
")

            # Register new task definition revision
            NEW_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEF" \
              --region "$REGION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            echo "  Registered new revision: $NEW_ARN"

            # Force a new deployment on the service with the new revision
            aws ecs update-service \
              --cluster "$CLUSTER" \
              --service "$SERVICE" \
              --task-definition "$NEW_ARN" \
              --force-new-deployment \
              --region "$REGION" \
              --query 'service.{status:status,running:runningCount,desired:desiredCount}' \
              --output table

            echo "  Deployment triggered for: $SERVICE"
          }

          # Deploy all three services
          deploy_service "$API_SERVICE"
          deploy_service "$CONSUMER_SERVICE"
          deploy_service "$WORKER_SERVICE"

          echo ""
          echo "All services deployed in $REGION"
